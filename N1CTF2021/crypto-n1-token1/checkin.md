# checkin

参考了这篇writeup：https://project-euphoria.dev/blog/26-n1ctf-2021/。

设$x=2021*p+1120*q \ mod\ n $，我们已知，$h=x+x^{-1}$，容易得到$x^2−h*x+1≡0\ (\ mod\ n)$。

这里我们为了减少运行时间，需要把q的leading bits也算出一部分，已知p的高22位和n，我们可以算出q的高21位，第22位不确定是因为可能有进位。简单的计算方法就是：$q1=n//(p0<<490),q0=q1>>491$ 。这样我们已知p的高22位和q的高21位。从而我们将x做如下分解：

$x=2021*(p0*2^{490}+p1)+1120*(q0*2^{491}+q1)=(2021*p0*2^{490}+1120*q0*2^{491})+(2021*p1+1120*q1)$

前半部分记为x0，后半部分记为x1，其中x0已知，x1未知，x1的数量级大概在2**500左右，令$f(x)=x^2-hx+1$，最高次为2，根$x1<N^{1/2}$，那么我们可以用Coppersmith定理进行求解，但是需要注意epsilon值的设置，可以参考sage的[文档](https://doc.sagemath.org/html/en/reference/polynomial_rings/sage/rings/polynomial/polynomial_modn_dense_ntl.html#sage.rings.polynomial.polynomial_modn_dense_ntl.small_roots)。具体的联系我没有看论文，但是epsilon越大，解LLL的矩阵越大，耗时越长，得到解的概率越大。由X的bound的公式：

$X=ceil(\frac{1}{2}N^{β^2/δ−ϵ})$，由于N是1024比特，X的严格上界是2^505 (计算得的的解为2^502)，得到的epsilon应该小于0,009。由于是估算，可以稍微设置大一些，也能在多项式时间内得到解。这里设置epsilon为1/80可以得到解，只需要10min。

求解x1的代码如下：

```python
def CopperSmith():
    R = Zmod(n)
    PR.<x> = PolynomialRing(R)
    _x = 2021*p0*2^490 + 1120*q0*2^491 + x
    f = (_x^2 - _x*h + 1).monic()
    # [7279473437564993427256268527891542563557232159626049883951364173102121134158423609775502464752174435483615142675582269470774951285125088232851515513237]
    # time cost 726 s
    roots = f.small_roots(X=2^505,epsilon=1/80)
    print(roots)
CopperSmith()
```



得到x1之后，我们可以得到了$x=2021p+1120q$的值，并且已知$2021p*1120q=2021*1120*n$，直接联立解方程即可，这里用z3解，脚本如下：

```python
from Crypto.Util.number import *
from z3 import *
n = 124592923216765837982528839202733339713655242872717311800329884147642320435241014134533341888832955643881019336863843062120984698416851559736918389766033534214383285754683751490292848191235308958825702189602212123282858416891155764271492033289942894367802529296453904254165606918649570613530838932164490341793
c = 119279592136391518960778700178474826421062018379899342254406783670889432182616590099071219538938202395671695005539485982613862823970622126945808954842683496637377151180225469409261800869161467402364879561554585345399947589618235872378329510108345004513054262809629917083343715270605155751457391599728436117833
h = 115812446451372389307840774747986196103012628652193338630796109042038320397499948364970459686079508388755154855414919871257982157430015224489195284512204803276307238226421244647463550637321174259849701618681565567468929295822889537962306471780258801529979716298619553323655541002084406217484482271693997457806
p0 = 4055618
e = 65537
# x^2 -hx + 1 = 0 mod n


if __name__ == "__main__":
    q1=n//(p0<<490)
    q0=q1>>491
    x=7279473437564993427256268527891542563557232159626049883951364173102121134158423609775502464752174435483615142675582269470774951285125088232851515513237
    S=Solver()
    _p=BitVec('_p',1080)
    _q=BitVec('_q',1080)
    S.add((_p*_q)==(n*2021*1120))
    S.add((_p+_q)==(1120*q0*2**491+2021*p0*2**490+x))
    ans=S.check()
    print(S.model())
    p=S.model()[_p].as_long()//2021
    q=S.model()[_q].as_long()//1120
    assert p*q==n
    phi=(p-1)*(q-1)
    d=inverse(e,phi)
    flag=pow(c,d,n)
    print(long_to_bytes(flag))
    # n1ctf{093fd4c4-5cc9-427e-98ef-5a04914c8b4e}
```

