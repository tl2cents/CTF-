from Crypto.Util.number import *
from Crypto.Hash import SHA

wl,cl1,cl2=[3912956711, 4013184893, 3260747771], [2852589223779928796266540600421678790889067284911682578924216186052590393595645322161563386615512475256726384365091711034449682791268994623758937752874750918200961888997082477100811025721898720783666868623498246219677221106227660895519058631965055790709130207760704, 21115849906180139656310664607458425637670520081983248258984166026222898753505008904136688820075720411004158264138659762101873588583686473388951744733936769732617279649797085152057880233721961, 301899179092185964785847705166950181255677272294377823045011205035318463496682788289651177635341894308537787449148199583490117059526971759804426977947952721266880757177055335088777693134693713345640206540670123872210178680306100865355059146219281124303460105424], [148052450029409767056623510365366602228778431569288407577131980435074529632715014971133452626021226944632282479312378667353792117133452069972334169386837227285924011187035671874758901028719505163887789382835770664218045743465222788859258272826217869877607314144, 1643631850318055151946938381389671039738824953272816402371095118047179758846703070931850238668262625444826564833452294807110544441537830199752050040697440948146092723713661125309994275256, 10949587016016795940445976198460149258144635366996455598605244743540728764635947061037779912661207322820180541114179612916018317600403816027703391110922112311910900034442340387304006761589708943814396303183085858356961537279163175384848010568152485779372842]

x1 = 10537190383977432819948602717449313819513015810464463348450662860435011008001132238851729268032889296600248226221086420035262540732157097949791756421026015741477785995033447663038515248071740991264311479066137102975721041822067496462240009190564238288281272874966280
y1 = 168450500310972930707208583777353845862723614274337696968629340838437927919365973736431467737825931894403582133125917579196621697175572833671789075169621831768398654909584273636143519940165648838850012943578686057625415421266321405275952938776845012046586285747

x2 = 121723653124334943327337351369224143389428692536182586690052931548156177466437320964701609590004825981378294358781446032392886186351422728173975231719924841105480990927174913175897972732532233
y2 = 1921455776649552079281304558665818887261070948261008212148121820969448652705855804423423681848341600084863078530401518931263150887409200101780191600802601105030806253998955929263882382004

x3 = 1440176324831562539183617425199117363244429114385437232965257039323873256269894716229817484088631407074328498896710966713912857642565350306252498754145253802734893404773499918668829576304890397994277568525506501428687843547083479356423917301477033624346211335450
y3 = 25220695816897075916217095856631009012504127590059436393692101250418226097323331193222730091563032067314889286051745468263446649323295355350101318199942950223572194027189199046045156046295274639977052585768365501640340023356756783359924935106074017605019787

vl=[x1,x2,x3]
ul=[y1,y2,y3]

def gen_pell_solu(min_solu,kthsolu,n):
    xnext=min_solu[0]*kthsolu[0]+n*min_solu[1]*kthsolu[1]
    ynext=min_solu[0]*kthsolu[1]+min_solu[1]*kthsolu[0]
    return [xnext,ynext]

# for i in range(3):
    # print(cl1[i].bit_length(),cl2[i].bit_length())
    # print(ul[i].bit_length(),vl[i].bit_length())
    
#sage
x=crt(cl1,vl)
m1=x.nth_root(7)
y=crt(cl2,ul)
m2=y.nth_root(7)

print(long_to_bytes(m1))
print(long_to_bytes(m2))

# h1 = bytes_to_long(SHA.new(m1).digest())
# h2 = bytes_to_long(SHA.new(m2).digest())

h1=63998600246749767922010292163233985055258508821
h2=1121013631791355094793010532678158450130791457285

def gcd(a,b):
    while a!=0:
        a,b = b%a,a
    return b

def findModReverse(a,m):
    if gcd(a,m)!=1:
        return None
    u1,u2,u3 = 1,0,a
    v1,v2,v3 = 0,1,m
    while v3!=0:
        q = u3//v3
        v1,v2,v3,u1,u2,u3 = (u1-q*v1),(u2-q*v2),(u3-q*v3),v1,v2,v3
    return u1%m

pq, p_1dq, t=85198615386075607567070020969981777827671873654631200472078241980737834438897900146248840279191139156416537108399682874370629888207334506237040017838313558911275073904148451540255705818477581182866269413018263079858680221647341680762989080418039972704759003343616652475438155806858735982352930771244880990190318526933267455248913782297991685041187565140859, 106239950213206316301683907545763916336055243955706210944736472425965200103461421781804731678430116333702099777855279469137219165293725500887590280355973107580745212368937514070059991848948031718253804694621821734957604838125210951711527151265000736896607029198, 60132176395922896902518845244051065417143507550519860211077965501783315971109433544482411208238485135554065241864956361676878220342500208011089383751225437417049893725546176799417188875972677293680033005399883113531193705353404892141811493415079755456185858889801456386910892239869732805273879281094613329645326287205736614546311143635580051444446576104548
r1,s1,s2=498841194617327650445431051685964174399227739376, 376599166921876118994132185660203151983500670896, 187705159843973102963593151204361139335048329243
# r2,s3=620827881415493136309071302986914844220776856282, 674735360250004315267988424435741132047607535029
m=pq//p_1dq
q=m.nth_root(2)
# q=895513916279543445314258868563331268261201605181
p=pq//q
phi=(p-1)*(q-1)
d=inverse(p*q-p-q,phi)
g=pow(t,d,pq)

G=GF(p)
g=G(g)

# 验证g的阶性质
assert g^q == 1

# print(p*q, (p-1)//q, t, sep=', ')
# p= p_1dq* q
# p_1dq* q^2=n
# print(r1, s1, s2, sep=', ')
# print(r2, s3, sep=', ')

r1,s1=r1,s1
r2,s2=r1,s2
k=(h1-h2)*findModReverse(s1-s2,q)%q

# print(pow(g, k, p) % q == r1)
# t = powmod(g, p*q-(p+q), p*q)

x=findModReverse(r1,q)*(k*s1-h1)%q
print("find x1 ",x)
print(long_to_bytes(x))

r2,s3=620827881415493136309071302986914844220776856282, 674735360250004315267988424435741132047607535029

# s3 = (hm1 + x2*r2) * invert(k, q) % q
x2=inverse(r2,q)*(k*s3-h1)%q

print("find x2 ",x2)
print(long_to_bytes(x2))



